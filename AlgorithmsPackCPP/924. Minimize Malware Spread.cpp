/*
A) The UnionFind DS has an extra aspect; the int sz(int node) function
This returns the size of the connected component containing the given node
Notice how the Edge struct isn't even used in my implementation!
ALSO, we use ccSize[y]+=ccSize[x]; in the link function
This way, the parent always has # of nodes in a component!

B) Assuming we have CCs (connected components) in the graph, there are 3 types:
i) Component A, containing ZERO malware nodes (thus, irrelevant)
ii) Component B, containing ONE malware node.  Removing it saves all nodes from being infected
iii) Component C, containing TWO malware nodes. A lost cause!!!
A special case: if ALL infected components have more than 1 malware node, return the node of the smallest index

C)  The minimumMalwareSpread function works thus:
1) Firstly, the input list of initial malware nodes is sorted
2) We build a UnionFind DS to represent the network AND find CCs.  It is of size n. For each edge in the graph, we use union_set to MERGE the TWO CCs represented by the edge.  This doesn't need an edge struct, btw
3) We use the rootMalwareCount vector (intitialized to n) to store the count of the number of malware nodes in each CC
3b)  We run rootMalwareCount[uf.findSet(node)]++ on it
4)  We initialize our nodeRemove (initial answer) to initial[0], and maxInfected to -1
5)  We iterate over the initial list of malware nodes
6)  For each node, we find the parent CC, and 
7)  ...check if there's ONLY ONE malware node in that CC
8)  If there's ONLY ONE malware node, we check the size of the CC
9)  If the size of the CC is greater than maxInfected, we update maxInfected and nodeRemove
10) Finally, we return the nodeRemove variable.  The nodeRemove variable represents the node to remove to minimize the number of nodes infected by malware!
*/

class UnionFind{
    private:
    int forests{};
    vector<int>ccSize,parent;

    void link(int x, int y){
        if(ccSize[x] > ccSize[y])
            swap(x,y);
        parent[x] = y;
        ccSize[y]+=ccSize[x];
    }

    public:
    UnionFind(int n){
        forests = n;
        parent = vector<int>(n);
        ccSize = vector<int>(n);

        for(int i = 0; i < n; i++){
            ccSize[i] = 1;
            parent[i] = i;
        }
    }

    int find_set(int x){
        if(x==parent[x])
            return x;
        return parent[x] = find_set(parent[x]);
    }

    bool union_set(int x, int y){
        x = find_set(x);
        y = find_set(y);
        if(x!=y){
            link(x,y);
            --forests;
        }
        return x!=y;
    }

    int sz(int node){
        return ccSize[find_set(node)];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        sort(initial.begin(),initial.end());
        int n = graph.size();
        UnionFind uf(n);

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(graph[i][j]==1)
                    uf.union_set(i,j);
            }
        }

        vector<int>rootMalwareCount(n);
        for(int node:initial)
            rootMalwareCount[uf.find_set(node)]+=1;
        
        int nodeRemove = initial[0];
        int maxInfected = -1;

        for(int node:initial){
            int parentCC = uf.find_set(node);
            if(rootMalwareCount[parentCC]==1){
                if(maxInfected < uf.sz(parentCC)){
                    maxInfected = uf.sz(parentCC);
                    nodeRemove = node;
                }
            }
        }

        return nodeRemove;
    }
};